export interface Backoff {
    success(): void;
    fail(): number;
}
/**
 * Implements exponential backoff and jitter. This class tracks successful connections and failures
 * and produces a retry delay.
 *
 * It does not start any timers or directly control a connection.
 *
 * The backoff follows an exponential backoff scheme with 50% jitter starting at
 * initialRetryDelayMillis and capping at MAX_RETRY_DELAY.  If RESET_INTERVAL has elapsed after a
 * success, without an intervening faulure, then the backoff is reset to initialRetryDelayMillis.
 */
export declare class DefaultBackoff {
    private readonly _retryResetIntervalMillis;
    private readonly _random;
    private _retryCount;
    private _activeSince?;
    private _initialRetryDelayMillis;
    /**
     * The exponent at which the backoff delay will exceed the maximum.
     * Beyond this limit the backoff can be set to the max.
     */
    private readonly _maxExponent;
    constructor(initialRetryDelayMillis: number, _retryResetIntervalMillis: number, _random?: () => number);
    private _backoff;
    private _jitter;
    /**
     * This function should be called when a connection attempt is successful.
     *
     * @param timeStampMs The time of the success. Used primarily for testing, when not provided
     * the current time is used.
     */
    success(timeStampMs?: number): void;
    /**
     * This function should be called when a connection fails. It returns the a delay, in
     * milliseconds, after which a reconnection attempt should be made.
     *
     * @param timeStampMs The time of the success. Used primarily for testing, when not provided
     * the current time is used.
     * @returns The delay before the next connection attempt.
     */
    fail(timeStampMs?: number): number;
}
//# sourceMappingURL=Backoff.d.ts.map