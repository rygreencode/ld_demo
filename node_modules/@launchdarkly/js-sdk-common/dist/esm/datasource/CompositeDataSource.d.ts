import { LDLogger } from '../api/logging';
import { DataSource, DataSourceState, LDDataSourceFactory } from '../api/subsystem/DataSystem/DataSource';
import { Backoff } from './Backoff';
/**
 * Represents a transition between data sources.
 */
export type Transition = 'switchToSync' | 'fallback' | 'recover' | 'stop';
/**
 * Given a {@link DataSourceState}, how long to wait before transitioning.
 */
export type TransitionConditions = {
    [k in DataSourceState]?: {
        durationMS: number;
        transition: Transition;
    };
};
/**
 * The {@link CompositeDataSource} can combine a number of {@link DataSystemInitializer}s and {@link DataSystemSynchronizer}s
 * into a single {@link DataSource}, implementing fallback and recovery logic internally to choose where data is sourced from.
 */
export declare class CompositeDataSource implements DataSource {
    private readonly _logger?;
    private readonly _transitionConditions;
    private readonly _backoff;
    private _initPhaseActive;
    private _initFactories;
    private _syncFactories;
    private _stopped;
    private _externalTransitionPromise;
    private _externalTransitionResolve?;
    private _cancelTokens;
    /**
     * @param initializers factories to create {@link DataSystemInitializer}s, in priority order.
     * @param synchronizers factories to create  {@link DataSystemSynchronizer}s, in priority order.
     */
    constructor(initializers: LDDataSourceFactory[], synchronizers: LDDataSourceFactory[], _logger?: LDLogger | undefined, _transitionConditions?: TransitionConditions, _backoff?: Backoff);
    start(dataCallback: (basis: boolean, data: any) => void, statusCallback: (status: DataSourceState, err?: any) => void): Promise<void>;
    stop(): Promise<void>;
    private _reset;
    /**
     * Determines the next datasource and returns that datasource as well as a closure to cull the
     * datasource from the datasource lists. One example where the cull closure is invoked is if the
     * datasource has an unrecoverable error.
     */
    private _pickDataSource;
    /**
     * @returns the transition condition for the provided data source state or undefined
     * if there is no transition condition
     */
    private _lookupTransitionCondition;
    private _cancellableDelay;
    private _consumeCancelToken;
    /**
     * This wrapper will ensure the following:
     *
     * Don't report DataSourceState.Initializing except as first status callback.
     * Map underlying DataSourceState.Closed to interrupted.
     * Don't report the same status and error twice in a row.
     */
    private _wrapStatusCallbackWithSanitizer;
}
//# sourceMappingURL=CompositeDataSource.d.ts.map